<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Jellron</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">

        <link rel="stylesheet" href="css/styles.css">
    </head>

    <body>
        <main>
            <noscript>
                This page requires JavaScript. Please enable it, then refresh this page.
            </noscript>

            <p>
                You <em>must</em> place your camera at eye-level, at least one foot away from your face, and in a
                reasonably well-lit area. If you do not, the model may not be able to detect your face or body and
                some of the calculations may be inaccurate.
            </p>

            <p><b>To start the demo, select a video input device from the dropdown below.</b></p>

            <form>
                <fieldset id="webcam-settings">
                    <legend>Webcam</legend>

                    <fieldset>
                        <legend>Settings</legend>

                        <label>
                            Select a Video Input Device:
                            <select disabled name="video-input-devices" id="video-input-device-select"></select>
                        </label>
                        <label>
                            Body Detector Ready:
                            <span id="body-detector-ready">False</span>
                        </label>
                        <label>
                            Face Detector Ready:
                            <span id="face-detector-ready">False</span>
                        </label>
                        <label>
                            Hand Detector Ready:
                            <span id="hand-detector-ready">False</span>
                        </label>
                    </fieldset>

                    <fieldset id="webcam-stats">
                        <legend>Stats</legend>

                        <p>These stats are updated every 100ms, and show data for the last 30 samples.</p>

                        <p>If either average detection time is too high, the demo will stop running.</p>

                        <table>
                            <thead>
                            <tr>
                                <th>Label</th>
                                <th>Min</th>
                                <th>avg</th>
                                <th>Max</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Body Detection Time</td>
                                <td id="body-detection-time-min"></td>
                                <td id="body-detection-time-avg"></td>
                                <td id="body-detection-time-max"></td>
                            </tr>
                            <tr>
                                <td>Face Mesh Detection Time</td>
                                <td id="face-mesh-detection-time-min"></td>
                                <td id="face-mesh-detection-time-avg"></td>
                                <td id="face-mesh-detection-time-max"></td>
                            </tr>
                            <tr>
                                <td>Hand Detection Time</td>
                                <td id="hand-detection-time-min"></td>
                                <td id="hand-detection-time-avg"></td>
                                <td id="hand-detection-time-max"></td>
                            </tr>
                            <tr>
                                <td>Mesh Draw Time</td>
                                <td id="mesh-draw-time-min"></td>
                                <td id="mesh-draw-time-avg"></td>
                                <td id="mesh-draw-time-max"></td>
                            </tr>
                            </tbody>
                        </table>
                    </fieldset>
                </fieldset>

                <fieldset id="keypoint-settings">
                    <legend>Keypoints</legend>

                    <fieldset>
                        <legend>Body</legend>

                        <label>
                            Show Body
                            <input type="checkbox" name="body" id="body-checkbox" checked>
                        </label>
                    </fieldset>

                    <fieldset>
                        <legend>Face</legend>

                        <label>
                            Show Face
                            <input type="checkbox" name="face" id="face-checkbox" checked>
                        </label>
                    </fieldset>

                    <fieldset>
                        <legend>Hands</legend>

                        <label>
                            Show Hands
                            <input type="checkbox" name="hands" id="hands-checkbox" checked>
                        </label>
                    </fieldset>

                    <fieldset>
                        <legend>Necklace</legend>

                        <label>
                            Show Necklace
                            <input type="checkbox" name="necklace" id="necklace-checkbox" checked>
                        </label>
                        <label>
                            xOffset:
                            <input type="number" name="necklace-x-offset" id="necklace-x-offset-input" value="0" step="1">
                        </label>

                        <label>
                            yOffset:
                            <input type="number" name="necklace-y-offset" id="necklace-y-offset-input" value="0" step="1">
                        </label>

                        <label>
                            zOffset:
                            <input type="number" name="necklace-z-offset" id="necklace-z-offset-input" value="0" step="1">
                        </label>
                    </fieldset>

                    <fieldset>
                        <legend>Choker</legend>

                        <p>
                            The choker's position is relative to the necklace's position. Any changes to the necklace's
                            position will also affect the choker's position.
                        </p>

                        <label>
                            Show Choker
                            <input type="checkbox" name="choker" id="choker-checkbox" checked>
                        </label>
                        <label>
                            xOffset:
                            <input type="number" name="choker-x-offset" id="choker-x-offset-input" value="0" step="1">
                        </label>
                        <label>
                            yOffset:
                            <input type="number" name="choker-y-offset" id="choker-y-offset-input" value="0" step="1">
                        </label>
                        <label>
                            zOffset:
                            <input type="number" name="choker-z-offset" id="choker-z-offset-input" value="0" step="1">
                        </label>
                    </fieldset>

                    <fieldset>
                        <legend>Earlobes</legend>

                        <label>
                            Show Earlobes
                            <input type="checkbox" name="earlobes" id="earlobes-checkbox" checked>
                        </label>

                        <fieldset>
                            <legend>Left</legend>

                            <label>
                                xOffset:
                                <input type="number" name="left-earlobe-x-offset" id="left-earlobe-x-offset-input" value="0" step="1">
                            </label>
                            <label>
                                yOffset:
                                <input type="number" name="left-earlobe-y-offset" id="left-earlobe-y-offset-input" value="0" step="1">
                            </label>
                            <label>
                                zOffset:
                                <input type="number" name="left-earlobe-z-offset" id="left-earlobe-z-offset-input" value="0" step="1">
                            </label>
                        </fieldset>

                        <fieldset>
                            <legend>Right</legend>

                            <label>
                                xOffset:
                                <input type="number" name="right-earlobe-x-offset" id="right-earlobe-x-offset-input" value="0" step="1">
                            </label>
                            <label>
                                yOffset:
                                <input type="number" name="right-earlobe-y-offset" id="right-earlobe-y-offset-input" value="0" step="1">
                            </label>
                            <label>
                                zOffset:
                                <input type="number" name="right-earlobe-z-offset" id="right-earlobe-z-offset-input" value="0" step="1">
                            </label>
                        </fieldset>
                    </fieldset>
                </fieldset>
            </form>

            <video autoplay playsinline>
                This page requires a browser that supports the <em>video</em> element.
            </video>

            <canvas></canvas>
        </main>
    </body>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core/dist/tf-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter/dist/tf-converter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl/dist/tf-backend-webgl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection/dist/face-landmarks-detection.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection/dist/pose-detection.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection/dist/hand-pose-detection.min.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
          }
        }
    </script>

    <script type="module">
        import {Camera} from "./js/camera.js";
        import {BodyDetector} from "./js/body_detector.js";
        import {FaceDetector} from "./js/face_detector.js";
        import {HandDetector} from "./js/hand_detector.js";
        import {Mesh} from "./js/mesh.js";
        import {MeshRenderer} from "./js/mesh_renderer.js";
        import {StatRecorder} from "./js/stat_recorder.js";
        import {WebGLRenderer} from "three";

        function getNumericInputValue(elementId) {
            const inputElement = document.getElementById(elementId);
            if (inputElement === null) {
                throw new Error(`Could not locate element using the ID "${elementId}".`);
            }

            return parseInt(inputElement.value);
        }

        const canvas = document.getElementsByTagName("canvas")[0];
        const glContext = new WebGLRenderer({
            alpha: true,
            canvas: canvas
        });
        glContext.autoClear = true;

        const mesh = new Mesh();
        const faceDetector = new FaceDetector();
        const bodyDetector = new BodyDetector();
        const handDetector = new HandDetector();
        const meshRenderer = new MeshRenderer();

        const faceDetectorStats = new StatRecorder(30);
        const bodyDetectorStats = new StatRecorder(30);
        const handDetectorStats = new StatRecorder(30);
        const meshRendererStats = new StatRecorder(30);

        const statsInterval = setInterval(() => {
            if (!bodyDetector.isRunning() && !faceDetector.isRunning() && !handDetector.isRunning()) {
                return;
            }

            faceDetectorStats.record(faceDetector.getLastRuntime());
            bodyDetectorStats.record(bodyDetector.getLastRuntime());
            handDetectorStats.record(handDetector.getLastRuntime());
            meshRendererStats.record(meshRenderer.getLastRuntime());

            document.getElementById("body-detection-time-min").innerText = bodyDetectorStats.getMinimum().toString();
            document.getElementById("body-detection-time-avg").innerText = bodyDetectorStats.getAverage().toString();
            document.getElementById("body-detection-time-max").innerText = bodyDetectorStats.getMaximum().toString();

            document.getElementById("face-mesh-detection-time-min").innerText = faceDetectorStats.getMinimum().toString();
            document.getElementById("face-mesh-detection-time-avg").innerText = faceDetectorStats.getAverage().toString();
            document.getElementById("face-mesh-detection-time-max").innerText = faceDetectorStats.getMaximum().toString();

            document.getElementById("hand-detection-time-min").innerText = handDetectorStats.getMinimum().toString();
            document.getElementById("hand-detection-time-avg").innerText = handDetectorStats.getAverage().toString();
            document.getElementById("hand-detection-time-max").innerText = handDetectorStats.getMaximum().toString();

            document.getElementById("mesh-draw-time-min").innerText = meshRendererStats.getMinimum().toString();
            document.getElementById("mesh-draw-time-avg").innerText = meshRendererStats.getAverage().toString();
            document.getElementById("mesh-draw-time-max").innerText = meshRendererStats.getMaximum().toString();

            if (faceDetectorStats.getAverage() > 500) {
                console.error("Average face detection time is too high. Stopping face detection.");
                faceDetector.stop();
            }

            if (bodyDetectorStats.getAverage() > 500) {
                console.error("Average body detection time is too high. Stopping face detection.");
                bodyDetector.stop();
            }

            if (handDetectorStats.getAverage() > 500) {
                console.error("Average hand detection time is too high. Stopping face detection.");
                handDetector.stop();
            }

            if (!bodyDetector.isRunning() && !faceDetector.isRunning() && !handDetector.isRunning()) {
                console.error("All detectors have stopped. Stopping mesh renderer and stats recorder.");
                meshRenderer.stop();
                clearInterval(statsInterval);
            }
        }, 100);

        const warmupInterval = setInterval(() => {
            if (bodyDetector.isReady() && faceDetector.isReady() && handDetector.isReady()) {
                clearInterval(warmupInterval);

                document.getElementById("body-detector-ready").innerText = "True";
                document.getElementById("face-detector-ready").innerText = "True";
                document.getElementById("hand-detector-ready").innerText = "True";
                document.getElementById("video-input-device-select").disabled = false;
            }
        }, 100);

        const deviceSelect = await Camera.createOrUpdateSelectElement(document.getElementById("video-input-device-select"));
        deviceSelect.onchange = async () => {
            try {
                const camera = await new Camera(deviceSelect.value);
                const videoElement = await camera.createOrUpdateVideoElement(document.getElementsByTagName("video")[0]);

                videoElement.height = await camera.getHeight();
                videoElement.width = await camera.getWidth();

                glContext.setSize(await camera.getWidth(), await camera.getHeight());

                await bodyDetector.start(15, videoElement, mesh);
                await faceDetector.start(30, videoElement, mesh);
                await handDetector.start(10, videoElement, mesh);
                meshRenderer.start(60, glContext, mesh);
            } catch (error) {
                console.error(error);

                bodyDetector.stop();
                faceDetector.stop();
                handDetector.stop();
                meshRenderer.stop();
            }
        };



        // Register Listeners for Body Settings
        let element = document.getElementById("body-checkbox");
        element.addEventListener("change", () => {
            const element = document.getElementById("body-checkbox");
            meshRenderer.setDisplayBody(element.checked);
        });


        // Register Listeners for Face Settings
        element = document.getElementById("face-checkbox");
        element.addEventListener("change", () => {
            const element = document.getElementById("face-checkbox");
            meshRenderer.setDisplayFace(element.checked);
        });



        // Register Listeners for Hand Settings
        element = document.getElementById("hands-checkbox");
        element.addEventListener("change", () => {
            const element = document.getElementById("hands-checkbox");
            meshRenderer.setDisplayHands(element.checked);
        });



        // Register Listeners for Choker Settings
        element = document.getElementById("choker-checkbox");
        element.addEventListener("change", () => {
            const element = document.getElementById("choker-checkbox");
            meshRenderer.setDisplayChoker(element.checked);
        });

        function updateChokerOffsets() {
            const xOffset = getNumericInputValue("choker-x-offset-input");
            const yOffset = getNumericInputValue("choker-y-offset-input");
            const zOffset = getNumericInputValue("choker-z-offset-input");
            mesh.setChokerOffsets(xOffset, yOffset, zOffset);
        }

        element = document.getElementById("choker-x-offset-input");
        element.addEventListener("change", () => updateChokerOffsets());

        element = document.getElementById("choker-y-offset-input");
        element.addEventListener("change", () => updateChokerOffsets());

        element = document.getElementById("choker-z-offset-input");
        element.addEventListener("change", () => updateChokerOffsets());



        // Register Listeners for Necklace Settings
        element = document.getElementById("necklace-checkbox");
        element.addEventListener("change", () => {
            const element = document.getElementById("necklace-checkbox");
            meshRenderer.setDisplayNecklace(element.checked);
        });

        function updateNecklaceOffsets() {
            const xOffset = getNumericInputValue("necklace-x-offset-input");
            const yOffset = getNumericInputValue("necklace-y-offset-input");
            const zOffset = getNumericInputValue("necklace-z-offset-input");
            mesh.setNecklaceOffsets(xOffset, yOffset, zOffset);
        }

        element = document.getElementById("necklace-x-offset-input");
        element.addEventListener("change", () => updateNecklaceOffsets());

        element = document.getElementById("necklace-y-offset-input");
        element.addEventListener("change", () => updateNecklaceOffsets());

        element = document.getElementById("necklace-z-offset-input");
        element.addEventListener("change", () => updateNecklaceOffsets());



        // Register Listeners for Earlobe Settings
        element = document.getElementById("earlobes-checkbox");
        element.addEventListener("change", () => {
            const element = document.getElementById("earlobes-checkbox");
            meshRenderer.setDisplayEarlobes(element.checked);
        });


        // Register Listeners for Left Earlobe Settings
        function updateLeftEarlobeOffsets() {
            const xOffset = getNumericInputValue("left-earlobe-x-offset-input");
            const yOffset = getNumericInputValue("left-earlobe-y-offset-input");
            const zOffset = getNumericInputValue("left-earlobe-z-offset-input");
            mesh.setLeftEarlobeOffsets(xOffset, yOffset, zOffset);
        }

        element = document.getElementById("left-earlobe-x-offset-input");
        element.addEventListener("change", () => updateLeftEarlobeOffsets());

        element = document.getElementById("left-earlobe-y-offset-input");
        element.addEventListener("change", () => updateLeftEarlobeOffsets());

        element = document.getElementById("left-earlobe-z-offset-input");
        element.addEventListener("change", () => updateLeftEarlobeOffsets());



        // Register Listeners for Right Earlobe Settings
        function updateRightEarlobeOffsets() {
            const xOffset = getNumericInputValue("right-earlobe-x-offset-input");
            const yOffset = getNumericInputValue("right-earlobe-y-offset-input");
            const zOffset = getNumericInputValue("right-earlobe-z-offset-input");
            mesh.setRightEarlobeOffsets(xOffset, yOffset, zOffset);
        }

        element = document.getElementById("right-earlobe-x-offset-input");
        element.addEventListener("change", () => updateRightEarlobeOffsets());

        element = document.getElementById("right-earlobe-y-offset-input");
        element.addEventListener("change", () => updateRightEarlobeOffsets());

        element = document.getElementById("right-earlobe-z-offset-input");
        element.addEventListener("change", () => updateRightEarlobeOffsets());
    </script>
</html>